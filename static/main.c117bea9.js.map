{"version":3,"file":"static/main.c117bea9.js","mappings":"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","sources":["webpack://wyrms/./src/Action.ts","webpack://wyrms/./src/Direction.ts","webpack://wyrms/./src/Grid.ts","webpack://wyrms/./src/Point.ts","webpack://wyrms/./src/RelativeDirection.ts","webpack://wyrms/./src/Tile.ts","webpack://wyrms/./src/Wyrm.ts","webpack://wyrms/./src/app.ts","webpack://wyrms/./src/utils.ts","webpack://wyrms/webpack/bootstrap","webpack://wyrms/webpack/runtime/make namespace object","webpack://wyrms/./src/index.ts"],"sourcesContent":["export enum Action {\n    MoveForward = 0,\n    MoveLeft,\n    MoveRight,\n}\n","export enum Direction {\n    Up = 0,\n    Right,\n    Down,\n    Left,\n}\n","import { getRenderingContext, randomChance, randomInt, rotateDirection } from \"./utils\";\nimport { Point, moveInDirection } from \"./Point\";\nimport { Direction } from \"./Direction\";\nimport { RelativeDirection } from \"./RelativeDirection\";\nimport { Tile } from \"./Tile\";\nimport { Action } from \"./Action\";\nimport { Wyrm } from \"./Wyrm\";\n\nexport type GridNeighbors = [RelativeDirection, Tile][];\n\ntype ScoreTable = number[];\n\nconst tileScores: ScoreTable = [];\ntileScores[Tile.Empty] = 0;\ntileScores[Tile.Wall] = -1;\ntileScores[Tile.Food] = 1;\n\ntype ColorTable = string[];\n\nconst tileColors: ColorTable = [];\ntileColors[Tile.Empty] = \"#001328\";\ntileColors[Tile.Wall] = \"#feb3bf\";\ntileColors[Tile.Food] = \"#880e24\";\n\nconst wyrmColors: ColorTable = [\n    \"#92e790\",\n    \"#eafffb\",\n    \"#54ffdb\",\n    \"#fc2f25\",\n    \"#f92dc7\",\n    \"#d0f392\",\n    \"#b5f458\",\n    \"#e2f73a\",\n    \"#5ec0ff\",\n    \"#ffecaf\",\n    \"#efe5d2\",\n    \"#eff5a7\",\n    \"#4fe946\",\n    \"#9ddcff\",\n    \"#66a37c\",\n    \"#afebc6\",\n    \"#fed07d\",\n    \"#5aeb88\",\n    \"#ffd143\",\n    \"#38bc5e\",\n];\n\ninterface WyrmTable {\n    [id: number]: Wyrm;\n}\n\nexport interface GridOptions {\n    width: number;\n    height: number;\n    tileSize: number;\n    canvasElement: HTMLCanvasElement;\n}\n\nconst spawnInterval = 64;\n\nexport class Grid {\n    public width: number;\n    public height: number;\n    public tileSize: number;\n    public wyrms: WyrmTable;\n    private nextWyrmId: number;\n    private tiles: Uint8Array;\n    private stepCount: number;\n    private canvasElement: HTMLCanvasElement;\n    private context: CanvasRenderingContext2D;\n\n    constructor(options: GridOptions) {\n        this.width = options.width;\n        this.height = options.height;\n        this.tileSize = options.tileSize;\n\n        this.wyrms = {};\n        this.nextWyrmId = Tile.Wyrm;\n        this.stepCount = 0;\n\n        this.tiles = new Uint8Array(this.width * this.height);\n        this.fill();\n\n        this.canvasElement = options.canvasElement;\n        this.context = getRenderingContext(this.canvasElement);\n        this.setCanvasSize();\n    }\n\n    private setCanvasSize() {\n        const pixelWidth = this.width * this.tileSize;\n        const pixelHeight = this.height * this.tileSize;\n        this.canvasElement.width = pixelWidth * this.renderScale;\n        this.canvasElement.height = pixelHeight * this.renderScale;\n        this.canvasElement.style.width = `${pixelWidth}px`;\n        this.canvasElement.style.height = `${pixelHeight}px`;\n    }\n\n    private fill(): void {\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const position = { x, y };\n                const tile = this.atEdge(position)\n                    ? Tile.Wall\n                    : randomChance(1 / 16)\n                    ? Tile.Food\n                    : Tile.Empty;\n                this.setTile(position, tile);\n            }\n        }\n    }\n\n    step(): void {\n        if (this.stepCount > spawnInterval / 2 && this.stepCount % spawnInterval === 0) {\n            this.createRandomWyrm();\n        }\n\n        const wyrms = Object.keys(this.wyrms).map((id) => this.wyrms[+id]);\n        wyrms.sort((wyrm) => -wyrm.size);\n        wyrms.forEach((wyrm) => {\n            if (this.wyrms[wyrm.id]) {\n                wyrm.doBestAction();\n            }\n        });\n\n        this.stepCount++;\n    }\n\n    draw(): void {\n        for (let x = 0; x < this.width; x++) {\n            for (let y = 0; y < this.height; y++) {\n                const position = { x, y };\n                const tile = this.getTile(position);\n                const tileColor = this.getTileColor(tile);\n                const size = this.tileSize * this.renderScale;\n\n                this.context.fillStyle = tileColor;\n                this.context.fillRect(x * size, y * size, size, size);\n            }\n        }\n    }\n\n    private getTileColor(tile: Tile): string {\n        let i = tile as number;\n        if (i < Tile.Wyrm) {\n            return tileColors[i];\n        }\n\n        i = (i - Tile.Wyrm) % wyrmColors.length;\n        return wyrmColors[i];\n    }\n\n    getTileScore(tile: Tile): number {\n        const score = tileScores[tile];\n        if (score !== undefined) {\n            return score;\n        }\n\n        return -1;\n    }\n\n    createRandomWyrm(): void {\n        const x = Math.floor(this.width / 2);\n        const y = Math.floor(this.height / 2);\n        const position = { x, y };\n        const direction = randomInt(0, 3) as Direction;\n        this.createWyrm(position, direction);\n    }\n\n    createWyrm(position: Point, direction: Direction): void {\n        const currentTile = this.getTile(position);\n        if (currentTile === Tile.Wall || currentTile >= Tile.Wyrm) {\n            return;\n        }\n\n        const id = this.nextWyrmId++;\n        const wyrm = new Wyrm({ id, position, direction, grid: this });\n        this.wyrms[id] = wyrm;\n        this.setTile(position, id);\n    }\n\n    destroyWyrm(id: number): void {\n        const wyrm = this.wyrms[id];\n        delete this.wyrms[id];\n\n        wyrm.segments.forEach((position) => {\n            const tile = randomChance(1 / 4) ? Tile.Empty : Tile.Food;\n            this.setTile(position, tile);\n        });\n    }\n\n    fightWyrms(idA: number, idB: number): void {\n        const wyrmA = this.wyrms[idA];\n        const wyrmB = this.wyrms[idB];\n        const ratio = wyrmA.size / wyrmB.size;\n        const advantage = randomInt(8, 12) / 10;\n        const finalRatio = ratio * advantage;\n\n        let winner = wyrmA,\n            loser = wyrmB;\n        if (finalRatio < 0.5) {\n            (winner = wyrmB), (loser = wyrmA);\n        }\n\n        loser.die();\n        winner.doAction(Action.MoveForward);\n    }\n\n    getTile(position: Point): Tile {\n        const i = this.index(position);\n        return this.tiles[i];\n    }\n\n    getNeighbors(position: Point, direction: Direction): GridNeighbors {\n        const left = rotateDirection(direction, RelativeDirection.Left);\n        const right = rotateDirection(direction, RelativeDirection.Right);\n        const forwardPosition = moveInDirection(position, direction);\n        const leftPosition = moveInDirection(position, left);\n        const rightPosition = moveInDirection(position, right);\n        return [\n            [RelativeDirection.Forward, this.getTile(forwardPosition)],\n            [RelativeDirection.Left, this.getTile(leftPosition)],\n            [RelativeDirection.Right, this.getTile(rightPosition)],\n        ];\n    }\n\n    setTile(position: Point, tile: Tile): void {\n        const i = this.index(position);\n        this.tiles[i] = tile;\n    }\n\n    private atEdge(position: Point): boolean {\n        const { x, y } = position;\n        return y === 0 || y === this.height - 1 || x === 0 || x === this.width - 1;\n    }\n\n    private index(position: Point) {\n        return position.y * this.width + position.x;\n    }\n\n    private get renderScale(): number {\n        return window.devicePixelRatio;\n    }\n}\n","import { Direction } from \"./Direction\";\n\nexport interface Point {\n    x: number;\n    y: number;\n}\n\nexport function moveInDirection(point: Point, direction: Direction): Point {\n    const newPoint = { ...point };\n    switch (direction) {\n        case Direction.Up:\n            newPoint.y -= 1;\n            break;\n        case Direction.Right:\n            newPoint.x += 1;\n            break;\n        case Direction.Down:\n            newPoint.y += 1;\n            break;\n        case Direction.Left:\n            newPoint.x -= 1;\n            break;\n    }\n\n    return newPoint;\n}\n\nexport function wrapBounds(point: Point, width: number, height: number): Point {\n    const x = (point.x + width) % width;\n    const y = (point.y + height) % height;\n    return { x, y };\n}\n","export enum RelativeDirection {\n    Forward = 0,\n    Right,\n    Backward,\n    Left,\n}\n","export enum Tile {\n    Empty = 0,\n    Wall,\n    Food,\n    Wyrm,\n}\n","import { Point, moveInDirection } from \"./Point\";\nimport { Direction } from \"./Direction\";\nimport { RelativeDirection } from \"./RelativeDirection\";\nimport { Action } from \"./Action\";\nimport { Tile } from \"./Tile\";\nimport { Grid, GridNeighbors } from \"./Grid\";\nimport {\n    actionFromRelativeDirection,\n    randomChance,\n    relativeDirectionFromAction,\n    rotateDirection,\n} from \"./utils\";\n\nexport interface WyrmOptions {\n    id: number;\n    grid: Grid;\n    position: Point;\n    direction: Direction;\n}\n\nexport interface MoveParams {\n    direction: Direction;\n    grow: boolean;\n    poop: boolean;\n}\n\nexport class Wyrm {\n    id: number;\n    grid: Grid;\n    segments: [Point];\n    direction: Direction;\n\n    constructor(options: WyrmOptions) {\n        this.id = options.id;\n        this.grid = options.grid;\n        this.segments = [options.position];\n        this.direction = options.direction;\n    }\n\n    get size(): number {\n        return this.segments.length;\n    }\n\n    get head(): Point {\n        return this.segments[0];\n    }\n\n    doBestAction(): void {\n        const neighbors = this.grid.getNeighbors(this.head, this.direction);\n        const direction = this.selectBestDirection(neighbors);\n        const action = actionFromRelativeDirection(direction);\n        this.doAction(action);\n    }\n\n    private selectBestDirection(neighbors: GridNeighbors): RelativeDirection {\n        const sortedDirections = neighbors\n            .map(([direction, tile]) => {\n                const score = this.grid.getTileScore(tile);\n                return [direction, score];\n            })\n            .sort(([, scoreA], [, scoreB]) => scoreB - scoreA);\n        const [direction] = sortedDirections[0];\n        return direction;\n    }\n\n    doAction(action: Action): void {\n        const relativeDirection = relativeDirectionFromAction(action);\n        const direction = rotateDirection(this.direction, relativeDirection);\n        const destination = moveInDirection(this.head, direction);\n\n        const tileId = this.grid.getTile(destination) as number;\n        switch (tileId) {\n            case Tile.Wall:\n            case this.id:\n                return this.die();\n            case Tile.Empty:\n                return this.move({ direction, grow: false, poop: randomChance(1 / 32) });\n            case Tile.Food:\n                return this.move({ direction, grow: true, poop: false });\n            default:\n                if (!this.grid.wyrms[tileId]) {\n                    console.warn(`enemy wyrm #${tileId} is dead`);\n                    this.grid.setTile(destination, Tile.Empty);\n                    return;\n                }\n\n                return this.grid.fightWyrms(this.id, tileId);\n        }\n    }\n\n    private move({ direction, grow, poop }: MoveParams): void {\n        const destination = moveInDirection(this.head, direction);\n        this.grid.setTile(destination, this.id);\n        this.segments.unshift(destination);\n\n        if (!grow) {\n            const last = this.segments.pop() || destination;\n            const tile = poop ? Tile.Food : Tile.Empty;\n            this.grid.setTile(last, tile);\n        }\n\n        this.direction = direction;\n    }\n\n    die(): void {\n        this.grid.destroyWyrm(this.id);\n    }\n}\n","import { randomInt } from \"./utils\";\nimport { Direction } from \"./Direction\";\nimport { Grid } from \"./Grid\";\n\nexport class App {\n    private grid: Grid;\n    private lastStepTime: number;\n    private stepInterval: number;\n\n    constructor(canvasElement: HTMLCanvasElement) {\n        const tileSize = 8;\n        const width = Math.floor(window.innerWidth / tileSize);\n        const height = Math.floor(window.innerHeight / tileSize);\n        canvasElement.addEventListener(\"click\", this.onClick.bind(this));\n\n        this.grid = new Grid({ width, height, tileSize, canvasElement });\n        this.lastStepTime = 0;\n        this.stepInterval = 1000 / 16;\n        this.run();\n    }\n\n    private run(): void {\n        const update = (currentTime: number) => {\n            requestAnimationFrame(update);\n\n            const nextStepTime = this.lastStepTime + this.stepInterval;\n            if (currentTime >= nextStepTime) {\n                this.lastStepTime = currentTime;\n                this.grid.step();\n                this.grid.draw();\n            }\n        };\n\n        requestAnimationFrame(update);\n    }\n\n    private onClick(event: MouseEvent): void {\n        const x = Math.floor(event.offsetX / this.grid.tileSize);\n        const y = Math.floor(event.offsetY / this.grid.tileSize);\n        const position = { x, y };\n        const direction = randomInt(0, 3) as Direction;\n        this.grid.createWyrm(position, direction);\n        this.grid.step();\n    }\n}\n","import { Direction } from \"./Direction\";\nimport { RelativeDirection } from \"./RelativeDirection\";\nimport { Action } from \"./Action\";\n\nexport function actionFromRelativeDirection(direction: RelativeDirection): Action {\n    switch (direction) {\n        case RelativeDirection.Forward:\n            return Action.MoveForward;\n        case RelativeDirection.Left:\n            return Action.MoveLeft;\n        default:\n            return Action.MoveRight;\n    }\n}\n\nexport function getRenderingContext(canvasElement: HTMLCanvasElement): CanvasRenderingContext2D {\n    const context = canvasElement.getContext(\"2d\");\n    if (context === null) {\n        throw new Error(\"Can't initialize rendering context\");\n    }\n\n    return context;\n}\n\nexport function randomChance(n: number) {\n    return Math.random() < n;\n}\n\nexport function randomInt(min: number, max: number): number {\n    const range = max - min + 2;\n    return Math.floor(Math.random() * range) + min;\n}\n\nexport function relativeDirectionFromAction(action: Action): RelativeDirection {\n    switch (action) {\n        case Action.MoveForward:\n            return RelativeDirection.Forward;\n        case Action.MoveLeft:\n            return RelativeDirection.Left;\n        case Action.MoveRight:\n            return RelativeDirection.Right;\n    }\n}\n\nexport function rotateDirection(direction: Direction, offset: RelativeDirection): Direction {\n    return (direction + offset + 4) % 4;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { App } from \"./app\";\nimport \"./styles/index.scss\";\n\ndocument.addEventListener(\"DOMContentLoaded\", (_) => {\n    const canvasElement = document.createElement(\"canvas\");\n    document.body.appendChild(canvasElement);\n    new App(canvasElement);\n});\n"],"names":["Action","Direction","tileScores","Tile","Empty","Wall","Food","tileColors","wyrmColors","options","this","width","height","tileSize","wyrms","nextWyrmId","Wyrm","stepCount","tiles","Uint8Array","fill","canvasElement","context","getRenderingContext","setCanvasSize","pixelWidth","pixelHeight","renderScale","style","y","x","position","tile","atEdge","randomChance","setTile","step","spawnInterval","createRandomWyrm","Object","keys","map","id","sort","wyrm","size","forEach","doBestAction","draw","getTile","tileColor","getTileColor","fillStyle","fillRect","i","length","getTileScore","score","undefined","Math","floor","direction","randomInt","createWyrm","currentTile","grid","destroyWyrm","segments","fightWyrms","idA","idB","wyrmA","wyrmB","winner","loser","die","doAction","MoveForward","index","getNeighbors","left","rotateDirection","RelativeDirection","Left","right","Right","forwardPosition","moveInDirection","leftPosition","rightPosition","Forward","window","devicePixelRatio","Grid","point","newPoint","Up","Down","neighbors","head","selectBestDirection","action","actionFromRelativeDirection","sortedDirections","scoreA","relativeDirection","relativeDirectionFromAction","destination","tileId","move","grow","poop","console","warn","unshift","last","pop","innerWidth","innerHeight","addEventListener","onClick","bind","lastStepTime","stepInterval","run","update","currentTime","requestAnimationFrame","event","offsetX","offsetY","App","MoveLeft","MoveRight","getContext","Error","n","random","min","max","range","offset","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","r","Symbol","toStringTag","defineProperty","value","document","_","createElement","body","appendChild"],"sourceRoot":""}